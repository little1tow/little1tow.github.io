<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>自然语言推理介绍</title>
      <link href="/2018/05/28/NLI-introduce/"/>
      <url>/2018/05/28/NLI-introduce/</url>
      <content type="html"><![CDATA[<p>自然语言推理作为自然语言理解的一个重要组成部分，在整个自然语言理解中扮演着重要的角色，接下里我将对自然语言推理的现状做一简单总结，以下内容是我的小组分享的记录版。</p><h2 id="自然语言推理简介"><a href="#自然语言推理简介" class="headerlink" title="自然语言推理简介"></a>自然语言推理简介</h2><p><img src="/2018/05/28/NLI-introduce/2018-05-28-1.PNG" alt="Natural Language Inference"></p><p>自然语言推理主要是判断两个句子（Premise, Hypothesis）或者两个词之间的语义关系，为了保证模型能够集中在语义理解上，该任务最终退化为一个分类任务，目前类别主要是三分类（Entailment，Contradiction，Neutral）。目前对这三类有各种各样的定义，但是我认为这三类的分类依据还是要落在语义理解上，通过语义关系来确定类别。</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-2.PNG" alt="The importance of NLI"></p><p>那为什么要研究自然语言推理呢？简单来讲，机器学习的整个系统可以分为两块，输入，输出。输入要求我们能够输入一个机器能理解的东西，并且能够很好的表现出数据的特点，输出就是根据需要，生成我们需要的结果。也可以说整个机器学习可以分为Input Representation和Output Generation。因此，如何全面的表示输入就变得非常重要了。而自然语言推理是一个分类任务，使用准确率就可以客观有效的评价模型的好坏；这样我们就可以专注于语义理解和语义表示。并且如果这部分做得好的话，例如可以生成很好的句子表示的向量，那么我们就可以将这部分成果轻易迁移到其他任务中，例如对话，问答等。这一切都说明了研究自然语言推理是一个非常重要但是非常有意义的事情。</p><p>以下是自然语言推理推理的发展历程</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-3.PNG" alt="Path of NLI"></p><h2 id="相关数据"><a href="#相关数据" class="headerlink" title="相关数据"></a>相关数据</h2><p>上一部分对自然语言推理进行了一个大致的介绍。众所周知，数据对模型非常重要，而且深度神经网络也是高度依赖数据的，那么我们来对目前的数据进行一个简单的梳理</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-4.PNG" alt="SNLI"></p><p>这是自然语言推理领域一个非常重要的数据集，相关信息如上图所示，斯坦福大学通过众包的方式生成了这个自然语言推理领域第一个大规模人工标注的数据集，从此自然语言推理进入深度学习时代。</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-5.PNG" alt="Multi_NLI"></p><p>这个数据集和SNLI比较类似，但是它的前提句子来自真实场景的数据，因此在数据上更贴近现实一些，同时，每一条数据包含了类别信息。</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-7.PNG" alt="SciTail"></p><p>这个数据集就更加贴近现实了，前提句和假设句全都来自真实场景，人工的作用放到了对每一条数据打标签，因此数据本身的人工影响就变小了。但是该数据全部来自科学问答，因此在类别上可能略显单一。</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-6.PNG" alt="MPE"></p><p>该数据集和前边不同的地方在于它是四个前提句对应一个假设句，这样在进行推理分类时，不仅需要考虑前提句和假设句的关系，还需要考虑前提句之间的相关关系，因此推理难度更大，但是这些文本句子全都来自image captioning工作，文本本身人工较少，因此文本质量上可能不如前者。但这也是一个很有意思的方向。</p><p>当然，还有很多其他的数据集，例如SICK, Add-one RTE, JOCI等，都是从不同角度对语义理解提出了一个要求。可以说自然语言推理领域目前正是百花齐放，十分繁荣。</p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><h3 id="词级别的推理"><a href="#词级别的推理" class="headerlink" title="词级别的推理"></a>词级别的推理</h3><p><img src="/2018/05/28/NLI-introduce/2018-05-28-8.PNG" alt="CENN"></p><p>该方法主要研究的是词级别的推理。有研究表明，词具有不同方面的语义信息，例如book在名词角度可以表示为：书，但在动词角度可以表示为：预定；因此使用单一的向量可能无法有效区分这些内容，因此作者提出利用不同的上下文来获取词在不同角度的语义信息，例如：选取中心词周围的名词来表示它的topic信息，选取中心词周围的动词来表示它的function信息。这样对每个词就都有不同的语义向量表示，然后通过网络结构对相关信息进行拼接，最后考虑到不同的推理关系可能需要的信息时不同的，例如：上下位关系：狗-动物，可能需要的是topic相关的信息，因果关系：攻击-受伤，可能需要的更多的是function的信息，因此作者通过一个门结构计算出每种语义表示对推理关系的影响程度，然后进行加权求和，最后进行分类。并且该方法的可扩展性非常好，从网络结构上看，我们可以增加不同的语义表示，模型的结构和参数规模并不会有太大的提升，这也可以认为是模型的一个优点。</p><h3 id="句子级别的推理"><a href="#句子级别的推理" class="headerlink" title="句子级别的推理"></a>句子级别的推理</h3><p>句子级别的推理可以分为两部分，基于句子语义编码的方法和基于词匹配的方法，前者是首先将一个句子编码为向量，然后分析两个向量之间的关系；后者考虑更多的是词之间的匹配关系，不一定有句子的语义向量表示。</p><h4 id="句子语义编码方法"><a href="#句子语义编码方法" class="headerlink" title="句子语义编码方法"></a>句子语义编码方法</h4><p><img src="/2018/05/28/NLI-introduce/2018-05-28-11.PNG" alt="Sentence-encoding"></p><p>该方法就是句子编码的方法，首先左图展现了这类方法的一般结构，首先通过不同的方法得到每个句子的语义向量表示；在此基础上，对两个向量作拼接，相减，点乘来得到两个语义向量之间的关系，最后通过一个MLP进行分类，右图就是句子编码部分可以采用的方法，例如：通过双向LSTM，得到隐层状态，对隐层状态做max-pooling或者做attention，得到的加权表示就只句子的语义向量表示，最右边的图示利用了CNN的结构，我们都知道CNN是建立输入之间的局部关系，那么作者使用了多层的CNN，通过多层卷积，底层获取的是local部分的信息，那么越往上就可以得到更长范围内的信息，从而对句子语义进行建模，这也是一种很不错的方法。</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-10.PNG" alt="Inner-atten"></p><p>这个方法是对注意力机制（Attention Mechanism）的一种有效利用，我们可以清晰看出来，作者先对BiLSTM的隐层状态进行mean pooling，在此基础上，利用注意力机制得到句子中那些词对语义表示比较重要，然后对隐层状态进行加权求和，就得到了句子表示的向量，最后就是常用的框架。从该方法中我们也可以看到句子编码模型的基本结构。</p><h4 id="词匹配方法"><a href="#词匹配方法" class="headerlink" title="词匹配方法"></a>词匹配方法</h4><p> <img src="/2018/05/28/NLI-introduce/2018-05-28-12.PNG" alt="word-matching"></p><p>该方法是词匹配方法的一个代表工作，首先作者使用两个LSTM来处理两个句子，并且后一个LSTM的隐层使用前一个LSTM的最后一个状态初始化，在此基础上，作者在求后一个句子的隐层状态时，使用注意力机制考虑前提句子的每一个词的隐层状态，建立词之间的匹配关系，最后利用最后一个隐层状态作为最后分类的依据，在这个方法中我们看到，其实并没有句子语义向量的表示。</p><p><img src="/2018/05/28/NLI-introduce/2018-05-28-13.PNG" alt="word-matching1"></p><p>该方法在词匹配上进行了更深入的研究，不仅仅是计算他们的匹配程度，而是先求前提句中的每个词和假设句中的所有词之间的attention，并使用假设句中所有词乘以attention分布，来表示前提句中的每个词，这样就使用了对方的语义来表示自己，假设句也是一样。然后将得到的结果和原始的表示作拼接，通过变换，最后求一个和，得到句子的表示进行分类，该方法也是目前比较流行的方法，通过使用对方的语义来表示自己，从而对语义关系进行更好的建模。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Accuracy"><a href="#Accuracy" class="headerlink" title="Accuracy"></a>Accuracy</h3><p><img src="/2018/05/28/NLI-introduce/2018-05-28-14.PNG" alt="accuracy"></p><p>这是第一个也是很重要的问题，目前在SNLI数据集上，最好的结果已经做到89.3%，那么接下来如何提升准确率呢？这是一个值得思考的问题。</p><h3 id="Lexical-Knowledge"><a href="#Lexical-Knowledge" class="headerlink" title="Lexical Knowledge"></a>Lexical Knowledge</h3><p><img src="/2018/05/28/NLI-introduce/2018-05-28-15.PNG" alt="lexical-knowledge"></p><p>这个问题很有意思，从数据上考虑，他只是修改了前提句中的一个词得到假设句，对于我们人类来说，进行这样的区分十分容易，但是由于两个句子之间的词的高重合度，模型可能会认为这两个输入是一致的，尤其是不同的两个词属于同一类的时候，他们的词向量表示会更相似。如果数据中有这样的例子，那模型肯定没问题，但如果训练数据中没有这样的例子，但实际上如果模型能够很好地理解语义，这个应该不是问题，而事实上这对模型来说是一个巨大的问题，对于这些词级别的不同，模型该如何去衡量呢？</p><h3 id="Annotation-Artifacts"><a href="#Annotation-Artifacts" class="headerlink" title="Annotation Artifacts"></a>Annotation Artifacts</h3><p><img src="/2018/05/28/NLI-introduce/2018-05-28-16.PNG" alt="annotation-artifacts"></p><p>这也是一个很有意思的问题，如前边所介绍的，数据集都是使用了人工，尤其是有一些数据集的假设句子全都是人写的，理论上来说人写的句子肯定比模型生成的好，但是人写的句子也有一些特点，例如推理关系是Entailment的时候，可能假设句的一些名词是前提句的上位词（woman-&gt;people），如果是Contradiction的时候，那么假设句中可能就有很多否定词之类的。这些特点其实很好理解，但是如果模型发现了这些特征，那么它甚至可以只用假设句就能进行分类，但结果正确并没有什么用，模型并没有真正理解语义。如图作者进行了一些统计分析，可以看到有一些词和标签是有着紧密联系了，可以直接用这些词进行分类，但这些对语义理解并没有什么帮助。因此如何避免这些情况，准确理解语义也是一个非常重要的研究内容。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是我针对自然语言推理的一个简单介绍，作为自然语言理解的一个重要组成部分，这里边还是有很多很有意思的内容值得研究的。♪(＾∀＾●)ﾉ</p>]]></content>
      
      
        <tags>
            
            <tag> natural_language_inference </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github搭建个人博客记录</title>
      <link href="/2018/05/26/blog-start/"/>
      <url>/2018/05/26/blog-start/</url>
      <content type="html"><![CDATA[<p>作为一个工科生，但一直希望能够记录一些东西；同样作为一个工科生，有能力自己搭建博客。看了很多大神的github博客，最终决定也用hexo+github搭建一个自己的个人小站，记录下自己的一些足迹。</p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h2 id="github建立repository"><a href="#github建立repository" class="headerlink" title="github建立repository"></a>github建立repository</h2><p>在自己的github上新建repository，要注意的是name必须是username.github.io，该地址也是博客的地址，换成其他名字是不行的</p><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><p>安装git和node.js</p><blockquote><p>git地址：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><p>node.js地址：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p></blockquote><p>安装Hexo</p><blockquote><p>npm install -g hexo #-g表示全局安装, npm默认为当前项目安装</p></blockquote><h2 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h2><p>建立博客的根目录，（建议使用全英文目录，避免出现奇奇怪怪的bug），然后在该目录下打开git bash，（这里同样建议使用git bash，不使用windows terminal，因为windows terminal有一些log信息不会输出，这样就看不到哪里有问题了）</p><blockquote><p>hexo init #新建博客目录<br>hexo g #根据当前目录下文件生成静态网页<br>hexo s #启动服务器，还可以使用hexo s -p 4321，解决端口占用问题</p></blockquote><p>这样就可以在浏览器中输入localhost:4000查看了，</p><p>简单介绍一下文件目录，摘自<a href="http://www.shuang0420.com/2016/05/12/Github-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">这里</a></p><ul><li>public：执行hexo generate命令，输出的静态网页内容目录</li><li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li><li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li><li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li><li>drafts：草稿文章</li><li>posts：发布文章themes：主题文件目录</li><li>config.yml：全局配置文件，大多数的设置都在这里</li><li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮</li></ul><h2 id="Hexo-写文章"><a href="#Hexo-写文章" class="headerlink" title="Hexo 写文章"></a>Hexo 写文章</h2><blockquote><p> hexo new “postname” #然后在posts目录下的postname.md文件中编辑博客</p></blockquote><p>然后在source目录下打开对应的markdown文件，编辑即可，这里建议使用<a href="http://www.typora.io" target="_blank" rel="noopener">typora</a></p><h2 id="Hexo本地调试"><a href="#Hexo本地调试" class="headerlink" title="Hexo本地调试"></a>Hexo本地调试</h2><blockquote><p>hexo clean #清除之前生成的内容，保证不出问题<br>hexo g #生成<br>hexo s #启动本地服务，进行文章预览调试，也可以使用hexo s -p 4321</p></blockquote><h2 id="Hexo部署到github上"><a href="#Hexo部署到github上" class="headerlink" title="Hexo部署到github上"></a>Hexo部署到github上</h2><p>首先安装一个插件，保证能够使Hexo部署到GitHub上：</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p>在博客目录下找到配置文件_config.yml，进行编辑</p><p>编辑前：</p><blockquote><p># Deployment<br>##  Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type:</p></blockquote><p>编辑后：</p><blockquote><p>deploy:<br>  type: git<br>  repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制）<br>  branch: 分支（User Pages为master，Project Pages为gh-pages）</p></blockquote><p>然后执行：</p><blockquote><p>hexo g<br>hexo deploy</p></blockquote><p>之后就可以在浏览器中通过username.github.io进行浏览，棒棒哒</p><h2 id="优化部署和管理"><a href="#优化部署和管理" class="headerlink" title="优化部署和管理"></a>优化部署和管理</h2><p>虽然目前已经基本搭建好了博客，但是编辑只能在当前电脑编辑，github上保存的是生成之后的html文件，整个博客的源代码都在本地，那如果想要在别的电脑上编辑怎么办，这时候就要利用到github的分支，即在建立博客仓库的时候，建立两个分支，一个用于展示网站内容，一个用于存放hexo文件，</p><p>具体流程参考了<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more" target="_blank" rel="noopener">这里</a></p><h3 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h3><ol><li>创建仓库，username.github.io；</li><li>创建两个分支：master 与 hexo；</li><li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li><li>使用git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:username/username.github.io.git拷贝仓库；</li><li>在本地username.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li><li>修改_config.yml中的deploy参数，分支应为master；</li><li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li><li>执行hexo generate -d生成网站并部署到GitHub上。</li></ol><p>这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。</p><h3 id="日常修改"><a href="#日常修改" class="headerlink" title="日常修改"></a>日常修改</h3><p>在本地对博客进行修改，一般是如下步骤</p><ol><li>git pull  (在保证本地没有修改的情况下，更新到github上的版本，保持版本一致，非常重要)</li><li>进行各种编辑，修改操作</li><li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）</li><li>然后才执行hexo generate -d发布网站到master分支上</li></ol><h3 id="异地修改"><a href="#异地修改" class="headerlink" title="异地修改"></a>异地修改</h3><p>当在不同的电脑上修改时，一般是如下步骤</p><ol><li>使用git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:username/username.github.io.git拷贝仓库（默认分支为hexo）</li><li>在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git</li><li>然后就是日常修改中的2以后的操作</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>果然自己搭，坑不是一般的多，后续会慢慢更新，记录我在使用过程中踩过的坑↖(^ω^)↗</p>]]></content>
      
      
        <tags>
            
            <tag> notes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/01/01/hello-world/"/>
      <url>/2018/01/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>. test2</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
